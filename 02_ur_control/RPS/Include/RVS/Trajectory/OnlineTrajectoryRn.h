// Copyright (c) RVBUST, Inc - All rights reserved.
#pragma once
#include "OnlineTrajectory.h"

namespace RVS
{
///@addtogroup Trajectory
///@{

/**
 * @brief Giving start state (q0, v0, a0), and acceleration and jerk limits,
 * computing the shortest trajectory ending with a rest state (velocity and
 * acceleration are both zero).
 *
 * @note This method only calculates one-dof trajectory, for multiple DoFs, the
 * synchronization of multiple axes need to be considered.
 *
 * @param q0 start position
 * @param v0 start velocity
 * @param a0 start acceleration
 * @param amax max acceleration
 * @param jmax max jerk
 * @return PSpline1d::Ptr
 */
PSpline1d::Ptr ComputeFastestStopTrajectory(double q0, double v0, double a0,
                                            double amax, double jmax);

/**
 * @brief This is the specification of Rn online trajectory using nonlinear
 * filter or TopiCo library.
 *
 * @tparam Rxd
 */
template <>
class OnlineTrajectory<Rxd>
{
public:
    using Group = Rxd;
    using Tangent = typename Group::Tangent;
    using Curvature = typename Group::Tangent;
    using Torsion = typename Group::Tangent;

    /**
     * @brief Construct a new OnlineTrajectory object
     *
     * @note When initializing, we can use target state same with start state
     *
     * @param start start state
     * @param target target state
     * @param vel_limits velocity limits
     * @param acc_limits acceleration limits
     * @param jerk_limits jerk limits
     * @param period control period
     * @param speed_ratio trajectory speed_ratio
     * @param use_filter use nonlinear filter or TopiCo library, filter method
     * is more efficient for jogging 1 dof at most at the same time, TopiCo
     * method could handle the synchronization issue better when multiple axes
     * are jogging simultaneously.
     */
    OnlineTrajectory(const TrajectoryState<Group> &start,
                     const TrajectoryState<Group> &target,
                     const CVecXd &vel_limits, const CVecXd &acc_limits,
                     const CVecXd &jerk_limits, double period,
                     double speed_ratio = 1.0, bool use_filter = false);

    /**
     * @brief Compute the nest output state
     *
     * @return TrajectoryState<Group>
     */
    TrajectoryState<Group> ComputeNextState();

    /**
     * @brief Get the current state
     *
     * @return TrajectoryState<Group>
     */
    TrajectoryState<Group> GetCurrentState() const;

    /**
     * @brief Get the target state
     *
     * @return TrajectoryState<Group>
     */
    TrajectoryState<Group> GetTargetState() const;

    /**
     * @brief Get remain length, which is the distance between target state and
     * current state
     *
     * @return double
     */
    double GetRemainedLength() const;

    ///@brief Update trajectory if some constraints changed
    bool UpdateTrajectory();

    ///@brief Update target state, call UpdateTrajectory after setting new
    /// target state
    void UpdateTargetState(const TrajectoryState<Group> &state);

    ///@brief Update start state (current state), this is called seldomly
    void UpdateStartState(const TrajectoryState<Group> &state);

    ///@brief Update velocity limits
    void UpdateVelocityLimits(const CVecXd &vel_limits);

    ///@brief Update acceleration limits
    void UpdateAccelerationLimits(const CVecXd &acc_limits);

    ///@brief Update jerk limits
    void UpdateJerkLimits(const CVecXd &jerk_limits);

    ///@brief Update speed ratio
    void UpdateSpeedRatio(double speed_ratio);

    ///@brief Whether target state is reached or not
    bool IsReached() const;

    ///@brief Stop the trajectory as soon as possible
    bool StopTrajectory();

    ///@brief Get generated trajectory
    const std::vector<PSpline1d::Ptr> &GetTrajectory() const;

private:
    ///@brief Private implementation
    struct Impl;

    TrajectoryState<Group> m_current_state; ///< current state
    TrajectoryState<Group> m_target_state; ///< target state
    const CVecXd m_vel_limits_max; ///< velocity limits when speed ratio is 1.0
    CVecXd m_vel_limits; ///< actual velocity limits considering speed ratio
    CVecXd m_acc_limits; ///< acceleration limits
    CVecXd m_jerk_limits; ///< jerk limits
    double m_period; ///< control period
    bool m_using_filter; ///< using filter or topico

    const size_t m_dof; ///< trajectory dof
    double m_current_time; ///< current state time stamp, range [0, trajectory
                           ///< duration]
    bool m_is_stop_trajectory; ///< whether current trajectory is generated by
                               ///< StopTrajectory()
    std::shared_ptr<Impl> m_impl; ///< private implementaion
};
///@}
} // namespace RVS