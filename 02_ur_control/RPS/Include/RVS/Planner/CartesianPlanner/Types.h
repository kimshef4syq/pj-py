// Copyright (c) RVBUST, Inc - All rights reserved
#pragma once
#include <RVS/Planner/Core/Viapoint.h>
#include <RVS/Trajectory/TrajectoryBase.h>
#include <RVS/Trajectory/TrajectoryUtilsEx.h>
#include <RVS/Trajectory/TrajectorySpline.h>

namespace RVS
{

enum class PlanResult : int
{
    PlanResult_Unknow,
    PlanResult_GraphSearchFailed,
    PlanResult_LinearRefactorFailed,
    PlanResult_JerkFilteringFailed,
    PlanResult_Success
};

struct CartesianPlanResponse
{
    /** @brief clear response */
    void Clear()
    {
        joint_positions.clear();
        joint_trajectory = nullptr;
        joint_position_start = Rxd();
        joint_position_end = Rxd();
        result = PlanResult::PlanResult_Unknow;
    }
    /** @brief joint position list */
    std::vector<Rxd> joint_positions;
    /** @brief joint position at start of the trajectory*/
    Rxd joint_position_start;
    /** @brief joint position at end of the trajectory */
    Rxd joint_position_end;
    /** @brief joint trajectory */
    std::shared_ptr<TrajectoryRnSpline> joint_trajectory;
    /** @brief plan result*/
    PlanResult result;
};

struct CartesianPlanRequest
{
public:
    friend class CartesianPlanner;
    /** @brief construct CartesianPlanRequest */
    CartesianPlanRequest() {}

    ~CartesianPlanRequest() = default;

    /** @brief Set the joint seed for the cartesian trajectory to be solve */
    void SetSeedJointPosition(const JointVector &joint_seed)
    {
        m_joint_seed = joint_seed;
    }

    /** @brief request planner to generate stritly linear motion in between
     * waypoints, which may result in adding extra viapoints and computational
     * cost */
    void SetLinearRefactoring(bool linear_refactoring)
    {
        m_linear_refactoring = linear_refactoring;
    }

    /**
     * @brief Set the task redundancy of waypoints along the trajectory
     * @param lower_bound: task redundancy lower bound (i.e. SE3 space region
     * lower bound) represented in SE3Tangent
     * @param upper_bound: task redundancy lower bound (i.e. SE3 space region
     * upper bound) represented in SE3Tangent
     * @param num_redundancy_samples: the number of redundancy samples in each
     * dimension of SE3Tangent, should be of size 6
     * @return false
     */
    bool SetGlobalTaskRedundancy(SE3Tangentd lower_bound,
                                 SE3Tangentd upper_bound,
                                 std::array<size_t, 6> num_redundancy_samples);
    /**
     * @brief Set the task redundancy of waypoints along the trajectory
     * @param lower_bound: task redundancy lower bound (i.e. SE3 space region
     * lower bound) represented in SE3Tangent
     * @param upper_bound: task redundancy lower bound (i.e. SE3 space region
     * upper bound) represented in SE3Tangent
     * @param num_redundancy_samples: the number of redundancy samples in each
     * dimension of SE3Tangent
     * @return false
     */
    bool SetGlobalTaskRedundancy(SE3Tangentd lower_bound,
                                 SE3Tangentd upper_bound,
                                 size_t num_redundancy_samples);

    /**
     * @brief create request directly from viapoints
     * @param viapoints: viapoints
     */
    bool Create(const std::list<ViapointPtr> &viapoints)
    {
        m_viapoint_list = viapoints;
        return true;
    }

    /** @brief create request from a cartesian trajectory
     *  @param cart_traj: the cartesian trajectory
     *  @param num_samples: viapoints are generated by performing an
     uniform-sample from the original trajectory. if `num_samples` == 0,
     the sampling will be done automatically by checking joint space distance
     (i.e. the manipulability)
     *  @param time_stamp_delta: the linear velocity is not required to be
     * strictly constant in many cases. if a waypoint `x` is required to be
     * passed at time constraint `2.3`, and `time_stamp_delta` is set to `0.1`,
     * then time stamp of `x` is finally be constrainted at [2.2, 2.4]
     */
    bool Create(const std::shared_ptr<TrajectoryBase<SE3d>> &cart_traj,
                size_t num_samples = 0, const double time_stamp_delta = 0.0);

    /** @brief create request by given waypoints and linear velocity
     *  @param waypoints: the waypoints should pass through
     *  @param linear_velocity: the linear velocity (no angular velocity
     * included) required.
     *  @param num_resamples: the number of resample points from the original
     * trajectory gernerated by linear intepolating waypoints
     *  @param time_stamp_delta: the linear velocity is not required to be
     * strictly constant in many cases. if a waypoint `x` is required to be
     * passed at time constraint `2.3`, and `time_stamp_delta` is set to `0.1`,
     * then time stamp of `x` is finally be constrainted at [2.2, 2.4]
     */
    bool Create(const std::vector<SE3d> &waypoints,
                const double linear_velocity, const size_t num_resamples = 0,
                const double acc_time = 0.2,
                const double time_stamp_delta = 0.0);

    /** @brief create request by given waypoints and time constraint of each
     * waypoint
     *  @param waypoints: the waypoints should pass through
     *  @param time_constraints: the corresponding time constraint of each
     * waypoint
     */
    bool Create(const std::vector<SE3d> &waypoints,
                const std::vector<TimeConstraint> &time_constraints);

    /** @brief create request by given waypoints and time stamps of each
     * waypoint
     *  @param waypoints: the waypoints should pass through
     *  @param time_stamps: the corresponding time stamps of each waypoint
     */
    bool Create(const std::vector<SE3d> &waypoints,
                const std::vector<double> &time_stamps);


    /** @brief Get the created viapoint list which contains all the informations
     * a Cartesian planner needed*/
    const std::list<ViapointPtr> &GetViapointList() const
    {
        return m_viapoint_list;
    }


protected:
    /** @brief viapoint list that will proceed by planner,
     *  Each viapoint contains the sufficient infomation included for the
     *  planner
     */
    std::list<ViapointPtr> m_viapoint_list;

    /** @brief request planner to generate stritly linear motion in between
     * waypoints, which may result in adding extra viapoints and computational
     * cost */
    bool m_linear_refactoring = false;

    /** @brief joint seed for the cartesian trajectory to solve */
    JointVector m_joint_seed = JointVector::IdentityStatic(0);

    /** @brief the region lower bound for Cartesian Waypoints */
    SE3Tangentd m_task_redundancy_lower_bound = SE3Tangentd(0, 0, 0, 0, 0, 0);

    /** @brief the region upper bound for Cartesian Waypoints */
    SE3Tangentd m_task_redundancy_upper_bound = SE3Tangentd(0, 0, 0, 0, 0, 0);

    /** @brief: the number of redundancy samples in each dimension of SE3Tangent
     */
    std::array<size_t, 6> m_num_redundancy_samples = {15, 15, 15, 15, 15, 15};
};


} // namespace RVS
