// Copyright (c) RVBUST, Inc - All rights reserved
#pragma once

#include <RVS/Common/Logger.h>
#include <RVS/Common/Macros.h>
#include <RVS/Planner/Core/Types.h>
#include <RVS/Kinematics/PoE.h>


namespace RVS
{
/// @addgroup Planner
/// @{

// the solver type of path planning (such as local planning or BiRRT search,
// etc.)
enum PPSolverType
{
    PPSolverType_Undef = 0, ///< undefined planner
    PPSolverType_Dummy = 1 ///< nonsense planner (will be removed subsequently)
};


RVS_CLASS_FORWARD(PathPlannerBase);

class PathPlannerBase
{
public:
    /**
     * @brief Construct a new path planner config object
     *
     * @param planner_name The path planner name
     * @param planner_type The path planner type. It is noteworthy that type
     * PPSolverType_Dummy is a nonsensical planner type, its existence merely
     * displays the integrity of function of Rtspplanner
     *
     */
    PathPlannerBase(const std::string &planner_name = "",
                    PPSolverType planner_type = PPSolverType_Undef);

    /**
     * @brief Get the path planner name
     *
     * @return const std::string& The name of the current path planner
     *
     */
    const std::string &GetPlannerName() const { return m_planner_name; }

    /**
     * @brief To check whether the path planner has been initialized
     * successfully
     *
     * @return RVSReturn The result (Succeeded or Uninitialized)
     */
    RVSReturn IsConfigured() { return m_is_configured; }

    /**
     * @brief Set the waypoints consisting of joint configurations
     *
     * @param waypoints The input joint configurations (joint angles) of
     * manipulator
     *
     */
    void SetRawWaypointsAtCS(const std::vector<ViapointPtr> &waypoints);

    /**
     * @brief Get the raw waypoints that the user initially inputs
     *
     * @return const std::vector<ViapointPtr>& The raw waypoints that the user
     * inputs
     *
     */
    const std::vector<ViapointPtr> &GetRawWaypointsAtCS() const
    {
        return m_waypoints;
    }

    /**
     * @brief To plan a minimal cost (time, length and so on) path with respect
     * to given criteria
     *
     * @return true The result that a valid path has been found
     * @return false The result that it fails to find a valid path
     *
     */
    virtual bool PlanPath() = 0;

    /**
     * @brief Get the minimized cost path
     *
     * @return const std::vector<JointVector>& The optimized ordered joint
     * configurations that are generated by path planner
     *
     */
    const std::vector<JointVector> &GetPath() const { return m_optimized_path; }

protected:
    // initialize the related parameters with some path planner
    virtual bool _InitializeParameters() = 0;

    std::vector<ViapointPtr> m_waypoints; ///< raw waypoints
    std::vector<JointVector>
        m_optimized_path; ///< path generated by path planner
    size_t m_dof; ///< the active freedom of degree of robot arm
    CVecXd m_weights; ///< the weights of joints of robot arm or components of
                      ///< pose of endeffector

    std::string m_planner_name; ///< path planner name
    PPSolverType m_planner_type; ///< path planner type
    RVSReturn m_is_configured; ///< check whether path planner has been
                               ///< properly initialized
};

class PathPlannerDummy : public PathPlannerBase
{
public:
    /**
     * @brief Construct a new path planner dummy object
     *
     * @param dof The degree of freedom of given manipulator
     *
     */
    PathPlannerDummy(size_t dof = 6);

    /**
     * @brief Construct a new path planner dummy object
     *
     * @param waypoints  The waypoints in joint space
     * @param dof The degree of freedom of given manipulator
     *
     */
    PathPlannerDummy(const std::vector<ViapointPtr> &waypoints, size_t dof = 6);
    /**
     * @brief To plan a minimal cost (time, length and so on) path with respect
     * to given criteria
     * @note See class PathPlannerBase for meanings of parameters
     *
     */
    virtual bool PlanPath() override;

protected:
    // initialize the related parameters with dummy path planner
    virtual bool _InitializeParameters() override;

private:
    std::vector<JointVector>
        m_waypoints_at_cs; ///< all waypoints in configuration
                           ///< space (represented by JointVector format)
};

// The factory for generating path planner in configuration space
struct PathPlannerFactory
{
    PathPlannerBasePtr Create(const std::string &planner_name)
    {
        if (planner_name == "PathPlannerDummy") {
            auto planner = std::make_shared<PathPlannerDummy>();
            return planner;
        }
        else {
            RVS_ERROR("The unknown type path planner!");
            return nullptr;
        }
    }
};


/// @}
} // namespace RVS