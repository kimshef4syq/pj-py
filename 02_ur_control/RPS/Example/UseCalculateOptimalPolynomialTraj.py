"""
As a integrad planner, we should treat each component of CartesianPlanner carefully.
As the back-end trajectory generator, the optimality of trajectory generated by `CalcPolyTrajectory`
should be evaluated. 

"""
from RVBUST.RPS import *
from IPython import embed

logger.SetLevelForAll(Logger.LoggerLevel_Debug)


def TestSinTraj():
    # Assume the path is a spiral line in 3d space
    s = np.linspace(0, 2 * np.pi, 10)
    qs = np.array([2.0 * np.sin(s), 2.0 * np.cos(s)]).T
    qs = np.c_[qs, s][:, 0].reshape(-1, 1)
    dof = qs.shape[1]

    dq_max = np.ones(dof) * 4  # joint velocity limits
    ddq_max = np.ones(dof) * 20  # joint acceleration limits
    dddq_max = []

    estimated_duration = 8.0
    ts = np.r_[0, np.add.accumulate(np.linalg.norm(qs[1:] - qs[:-1], axis=1))]
    ts *= (estimated_duration / ts[-1])

    t_start = time.time()
    # cpp version
    res, traj2 = CalcPolyTrajectory(qs, ts, 6, 3, dq_max, ddq_max)
    t_end = time.time()
    logger.Info(f"time elapsed: {t_end - t_start}")
    if not res:
        logger.Error("Failed to find a minimum jerk trajectory")
    else:
        PlotTraj(traj2)

    return


def TestSimpleTraj():
    np.set_printoptions(suppress=True)
    qs = np.array([[0], [1], [2], [3]])
    ts = np.array([0, 1, 2, 3])

    v_max = [1.4]
    a_max = [100]
    j_max = [100]

    t_start = time.time()
    # cpp version
    res, traj2 = CalcPolyTrajectory(qs, ts, 7, 3, v_max=v_max, a_max=a_max)
    t_end = time.time()
    logger.Info(f"time elapsed: {t_end - t_start}")
    if not res:
        logger.Error("Failed to find a minimum jerk trajectory")
    else:
        PlotTraj(traj2)


def TestGluingTraj():

    vmax = np.array([7.8,    6.6,    9.,    9.5,    9.4,   17.2])
    amax = np.array([32.,   27.,   37.,   39.,   39.,   72.])
    jmax = np.array([540.,  460.,  628.,  666.,  660., 1210.])

    qs = np.loadtxt(
        GetDataPath() + "Projects/ShoesGluing_FanQin/Waypoints/qs_0.15.txt")

    ts = np.loadtxt(
        GetDataPath() + "Projects/ShoesGluing_FanQin/Waypoints/ts_0.15.txt")

    t_start = time.time()
    res, traj2 = CalcPolyTrajectory(qs, ts, 5, 2, vmax, amax, jmax)
    t_end = time.time()
    logger.Info(f"time elapsed: {t_end - t_start}")
    if not res:
        logger.Error("Failed to find a minimum jerk trajectory")
    else:
        PlotTraj(traj2)


if __name__ == '__main__':
    TestSinTraj()
    TestSimpleTraj()
    TestGluingTraj()
